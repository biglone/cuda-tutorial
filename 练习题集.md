# CUDA 练习题集

> 通过这些练习，逐步掌握 CUDA 编程。从易到难，每个练习都有提示和解答思路。

---

## 📚 如何使用本练习题集

1. **按顺序完成**：练习从易到难排列
2. **先独立思考**：不要立即看提示
3. **编写并运行**：实际编写代码并测试
4. **验证结果**：确保输出正确
5. **优化代码**：思考是否有更好的方法

---

## 🌟 第一部分：基础练习

### 练习 1.1：线程问候

**难度**: ⭐

**目标**：修改 `hello_cuda.cu`，让每个线程打印自己的 `threadIdx` 和 `blockIdx`。

**要求**：
- 使用 3 个块，每块 5 个线程
- 输出格式：`线程 [块ID, 线程ID]`

**预期输出示例**：
```
线程 [0, 0]
线程 [0, 1]
...
线程 [2, 4]
```

<details>
<summary>💡 提示</summary>

```cuda
printf("线程 [%d, %d]\n", blockIdx.x, threadIdx.x);
```
</details>

---

### 练习 1.2：全局线程 ID

**难度**: ⭐

**目标**：编写核函数，计算并打印全局线程 ID。

**要求**：
- 使用 4 个块，每块 8 个线程
- 同时打印 `blockIdx.x`、`threadIdx.x` 和全局 ID

**公式**：
```
全局 ID = threadIdx.x + blockIdx.x * blockDim.x
```

<details>
<summary>💡 提示</summary>

```cuda
__global__ void printGlobalID() {
    int tid = threadIdx.x + blockIdx.x * blockDim.x;
    printf("块%d 线程%d -> 全局ID %d\n",
           blockIdx.x, threadIdx.x, tid);
}
```
</details>

---

### 练习 1.3：二维网格

**难度**: ⭐⭐

**目标**：创建一个 4×4 的线程网格，打印每个线程的 2D 坐标。

**要求**：
- 使用 `dim3` 定义 2×2 个块
- 每块有 2×2 个线程
- 输出格式：`位置 (x, y)`

**预期输出**：应该有 16 个位置，从 (0,0) 到 (3,3)

<details>
<summary>💡 提示</summary>

```cuda
__global__ void print2DPosition() {
    int x = threadIdx.x + blockIdx.x * blockDim.x;
    int y = threadIdx.y + blockIdx.y * blockDim.y;
    printf("位置 (%d, %d)\n", x, y);
}

int main() {
    dim3 blocks(2, 2);
    dim3 threads(2, 2);
    print2DPosition<<<blocks, threads>>>();
    cudaDeviceSynchronize();
}
```
</details>

---

## 🔧 第二部分：内存管理

### 练习 2.1：数组平方

**难度**: ⭐⭐

**目标**：编写程序，将数组每个元素平方。

**要求**：
- 输入：`[1, 2, 3, 4, 5]`
- 输出：`[1, 4, 9, 16, 25]`
- 完成所有内存管理步骤

**步骤**：
1. 主机分配并初始化数组
2. 设备分配内存
3. 复制 H→D
4. 执行核函数
5. 复制 D→H
6. 打印结果
7. 释放内存

<details>
<summary>💡 核函数提示</summary>

```cuda
__global__ void squareArray(int *arr, int n) {
    int tid = threadIdx.x + blockIdx.x * blockDim.x;
    if (tid < n) {
        arr[tid] = arr[tid] * arr[tid];
    }
}
```
</details>

---

### 练习 2.2：向量标量乘法

**难度**: ⭐⭐

**目标**：将向量的每个元素乘以一个常数。

**要求**：
- 输入向量：`[1.0, 2.0, 3.0, 4.0, 5.0]`
- 乘数：`3.0`
- 输出：`[3.0, 6.0, 9.0, 12.0, 15.0]`

**提示**：核函数需要两个参数：数组指针和乘数。

<details>
<summary>💡 解答思路</summary>

```cuda
__global__ void scalarMultiply(float *arr, float scalar, int n) {
    int tid = threadIdx.x + blockIdx.x * blockDim.x;
    if (tid < n) {
        arr[tid] = arr[tid] * scalar;
    }
}
```
</details>

---

### 练习 2.3：两个数组元素互换

**难度**: ⭐⭐⭐

**目标**：交换两个数组的元素。

**要求**：
- 输入：`A = [1, 2, 3]`, `B = [4, 5, 6]`
- 输出：`A = [4, 5, 6]`, `B = [1, 2, 3]`
- 需要一个临时数组吗？

<details>
<summary>💡 提示</summary>

方法 1：使用临时变量
```cuda
__global__ void swapArrays(int *a, int *b, int n) {
    int tid = threadIdx.x + blockIdx.x * blockDim.x;
    if (tid < n) {
        int temp = a[tid];
        a[tid] = b[tid];
        b[tid] = temp;
    }
}
```

方法 2：在主机端交换指针（更高效！）
```cuda
int *temp = d_a;
d_a = d_b;
d_b = temp;
```
</details>

---

## 🚀 第三部分：实际应用

### 练习 3.1：查找最大值（简化版）

**难度**: ⭐⭐⭐

**目标**：在小数组中找到最大值。

**要求**：
- 数组：`[3, 7, 2, 9, 1, 5]`
- 每个线程处理一个元素
- 将最大值写入 `result[threadIdx.x]`
- 在 CPU 端找出最终最大值

**注意**：这不是最优算法，但是好的练习。

<details>
<summary>💡 提示</summary>

```cuda
__global__ void findMax(int *arr, int *result, int n) {
    int tid = threadIdx.x;
    if (tid < n) {
        result[tid] = arr[tid];  // 每个线程写自己的值
    }
}

// 在主机端
int max = result[0];
for (int i = 1; i < n; i++) {
    if (result[i] > max) max = result[i];
}
```
</details>

---

### 练习 3.2：点积（Dot Product）

**难度**: ⭐⭐⭐

**目标**：计算两个向量的点积。

**公式**：
```
dot(A, B) = A[0]*B[0] + A[1]*B[1] + ... + A[n-1]*B[n-1]
```

**要求**：
- `A = [1, 2, 3]`
- `B = [4, 5, 6]`
- 结果：`1*4 + 2*5 + 3*6 = 32`

**步骤**：
1. 每个线程计算 `A[i] * B[i]`
2. 存入临时数组
3. 在 CPU 端求和

<details>
<summary>💡 核函数提示</summary>

```cuda
__global__ void dotProduct(float *a, float *b, float *c, int n) {
    int tid = threadIdx.x + blockIdx.x * blockDim.x;
    if (tid < n) {
        c[tid] = a[tid] * b[tid];
    }
}

// 主机端求和
float sum = 0;
for (int i = 0; i < n; i++) {
    sum += h_c[i];
}
```
</details>

---

### 练习 3.3：向量归一化

**难度**: ⭐⭐⭐⭐

**目标**：将向量归一化到 [0, 1] 范围。

**公式**：
```
normalized[i] = (value[i] - min) / (max - min)
```

**要求**：
- 输入：`[10, 20, 30, 40, 50]`
- 输出：`[0.0, 0.25, 0.5, 0.75, 1.0]`

**步骤**：
1. 找到最小值和最大值（在 CPU）
2. 用核函数归一化

<details>
<summary>💡 解答思路</summary>

```cuda
// 主机端找 min/max
float min = h_data[0], max = h_data[0];
for (int i = 1; i < n; i++) {
    if (h_data[i] < min) min = h_data[i];
    if (h_data[i] > max) max = h_data[i];
}

// 核函数
__global__ void normalize(float *data, float min, float max, int n) {
    int tid = threadIdx.x + blockIdx.x * blockDim.x;
    if (tid < n) {
        data[tid] = (data[tid] - min) / (max - min);
    }
}
```
</details>

---

### 练习 3.4：图像灰度化（模拟）

**难度**: ⭐⭐⭐⭐

**目标**：将 RGB 图像转换为灰度图。

**公式**：
```
gray = 0.299*R + 0.587*G + 0.114*B
```

**简化**：
- 用 1D 数组模拟 RGB 数据
- `[R0, G0, B0, R1, G1, B1, ...]`
- 输出灰度数组 `[gray0, gray1, ...]`

**示例**：
- 输入：`[255, 0, 0, 0, 255, 0, 0, 0, 255]`（红、绿、蓝三个像素）
- 输出：`[76.245, 149.685, 28.77]`

<details>
<summary>💡 提示</summary>

```cuda
__global__ void rgb2gray(float *rgb, float *gray, int numPixels) {
    int tid = threadIdx.x + blockIdx.x * blockDim.x;
    if (tid < numPixels) {
        int idx = tid * 3;  // RGB 数据中的起始位置
        float r = rgb[idx];
        float g = rgb[idx + 1];
        float b = rgb[idx + 2];
        gray[tid] = 0.299f * r + 0.587f * g + 0.114f * b;
    }
}
```
</details>

---

## 🏆 第四部分：挑战练习

### 练习 4.1：矩阵转置

**难度**: ⭐⭐⭐⭐

**目标**：转置一个矩阵。

**输入**（3×4 矩阵）：
```
1  2  3  4
5  6  7  8
9 10 11 12
```

**输出**（4×3 矩阵）：
```
1 5  9
2 6 10
3 7 11
4 8 12
```

**提示**：
- 用 1D 数组存储矩阵
- `A[row][col]` 在 1D 数组中的索引是 `row * width + col`
- 转置：`B[col][row] = A[row][col]`

<details>
<summary>💡 解答思路</summary>

```cuda
__global__ void transpose(float *input, float *output,
                         int rows, int cols) {
    int row = threadIdx.y + blockIdx.y * blockDim.y;
    int col = threadIdx.x + blockIdx.x * blockDim.x;

    if (row < rows && col < cols) {
        int input_idx = row * cols + col;
        int output_idx = col * rows + row;
        output[output_idx] = input[input_idx];
    }
}

// 启动配置
dim3 threads(16, 16);
dim3 blocks((cols + 15) / 16, (rows + 15) / 16);
transpose<<<blocks, threads>>>(d_input, d_output, rows, cols);
```
</details>

---

### 练习 4.2：矩阵加法

**难度**: ⭐⭐⭐⭐

**目标**：实现矩阵加法 `C = A + B`。

**要求**：
- 矩阵大小：4×4
- 使用 2D 线程配置
- 正确处理边界

<details>
<summary>💡 解答思路</summary>

```cuda
__global__ void matrixAdd(float *a, float *b, float *c,
                         int rows, int cols) {
    int row = threadIdx.y + blockIdx.y * blockDim.y;
    int col = threadIdx.x + blockIdx.x * blockDim.x;

    if (row < rows && col < cols) {
        int idx = row * cols + col;
        c[idx] = a[idx] + b[idx];
    }
}
```
</details>

---

### 练习 4.3：简单矩阵乘法

**难度**: ⭐⭐⭐⭐⭐

**目标**：实现朴素矩阵乘法（不考虑优化）。

**公式**：
```
C[i][j] = Σ(A[i][k] * B[k][j])  对所有 k
```

**要求**：
- A: 2×3 矩阵
- B: 3×2 矩阵
- C: 2×2 矩阵

**示例**：
```
A = [1 2 3]     B = [7  8]      C = [58  64]
    [4 5 6]         [9 10]          [139 154]
                    [11 12]
```

<details>
<summary>💡 解答思路</summary>

```cuda
__global__ void matrixMul(float *a, float *b, float *c,
                         int m, int n, int k) {
    // C 是 m×k, A 是 m×n, B 是 n×k
    int row = threadIdx.y + blockIdx.y * blockDim.y;
    int col = threadIdx.x + blockIdx.x * blockDim.x;

    if (row < m && col < k) {
        float sum = 0.0f;
        for (int i = 0; i < n; i++) {
            sum += a[row * n + i] * b[i * k + col];
        }
        c[row * k + col] = sum;
    }
}
```
</details>

---

## 📝 练习进度表

将你完成的练习打 ✓：

**基础练习**
- [ ] 1.1 线程问候
- [ ] 1.2 全局线程 ID
- [ ] 1.3 二维网格

**内存管理**
- [ ] 2.1 数组平方
- [ ] 2.2 向量标量乘法
- [ ] 2.3 数组互换

**实际应用**
- [ ] 3.1 查找最大值
- [ ] 3.2 点积
- [ ] 3.3 向量归一化
- [ ] 3.4 图像灰度化

**挑战练习**
- [ ] 4.1 矩阵转置
- [ ] 4.2 矩阵加法
- [ ] 4.3 矩阵乘法

---

## 🎯 自主项目建议

完成上述练习后，尝试这些项目：

1. **图像滤波器**：实现简单的模糊或边缘检测
2. **数值积分**：用蒙特卡洛方法计算圆周率
3. **排序算法**：实现并行的奇偶排序
4. **物理模拟**：简单的粒子碰撞系统

---

## 💬 调试技巧

练习中遇到问题？试试这些：

```cuda
// 1. 打印调试信息
__global__ void debugKernel() {
    if (threadIdx.x == 0 && blockIdx.x == 0) {
        printf("第一个线程的调试信息\n");
    }
}

// 2. 检查数组内容
for (int i = 0; i < 10; i++) {
    printf("h_data[%d] = %f\n", i, h_data[i]);
}

// 3. 验证配置
printf("启动 %d 块 × %d 线程 = %d 总线程\n",
       blocks, threads, blocks * threads);
```

---

**提示**：不要急于看答案！尝试自己解决，查阅文档，实验不同方法。这样学得更深入！

祝练习愉快！🚀
